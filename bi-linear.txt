def interpolateBilinear(self, imageArray, oldImageWidth, oldImageHeight, newImageArray, newImageWidth, newImageHeight):
        
        #* Loop on new image by two for loops, outer for rows(height) innner for columns(width)
        for i in range(newImageHeight):
            for j in range(newImageWidth):

                # Relative coordinates of the pixel in output space
                x_out = j / newImageWidth
                y_out = i / newImageHeight

                # Corresponding absolute coordinates of the pixel in input space
                x_in = (x_out * oldImageWidth)
                y_in = (y_out * oldImageHeight)

                # Nearest neighbours coordinates in input space
                x_prev = int(np.floor(x_in))
                x_next = x_prev + 1
                y_prev = int(np.floor(y_in))
                y_next = y_prev + 1

                # Sanitize bounds - no need to check for < 0
                x_prev = min(x_prev, oldImageWidth - 1)
                x_next = min(x_next, oldImageWidth - 1)
                y_prev = min(y_prev, oldImageHeight - 1)
                y_next = min(y_next, oldImageHeight - 1)
                
                # Distances between neighbour nodes in input space
                Dy_next = y_next - y_in
                Dy_prev = 1. - Dy_next # because next - prev = 1
                Dx_next = x_next - x_in
                Dx_prev = 1. - Dx_next # because next - prev = 1
            
                # Interpolate over 3 RGB layers
                newImageArray[i][j] = Dy_prev * (imageArray[y_next][x_prev] * Dx_next + imageArray[y_next][x_next] * Dx_prev) \
                    + Dy_next * (imageArray[y_prev][x_prev]* Dx_next + imageArray[y_prev][x_next] * Dx_prev)
        
        #* After looping on the image we return an array of zoomed image            
        return newImageArray